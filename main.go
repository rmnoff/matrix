package main

import (
  "flag"
  "log"
  "fmt"
  "time"
  "strconv"
  "strings"
  // "database/sql"

  "github.com/qiangxue/fasthttp-routing"
  "github.com/valyala/fasthttp"
  // _ "github.com/jackc/pgx"
  // "github.com/jmoiron/sqlx"
)

var (
  addr     = flag.String("addr", ":8080", "TCP address to listen to")
  endpoint = "api"
  version  = "v1"
)

var schema = `
CREATE TABLE IF NOT EXISTS prediction (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  content TEXT,
  edited DATE,
  created DATE,
  type_id INT
);

CREATE TABLE IF NOT EXISTS check (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  firstname VARCHAR(255),
  lastname VARCHAR(255),
  birthdate TEXT,
  owner_id INT
);

CREATE TABLE IF NOT EXISTS predictionRel (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  prediction_id INT,
  combination VARCHAR(255)
);

CREATE TABLE IF NOT EXISTS predictionType (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(255)
);

CREATE TABLE IF NOT EXISTS constantText (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  content TEXT,
  edited DATE,
  created DATE,
  type_id INT
);

CREATE TABLE IF NOT EXISTS constantType (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(255)
);

CREATE TABLE IF NOT EXISTS user (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email VARCHAR(255),
  firstname VARCHAR(255),
  lastname VARCHAR(255),
  password TEXT,
  birthdate TEXT,
  gender BOOLEAN
);`


func main() {
  flag.Parse()

  ep := fmt.Sprintf("/%s/%s", endpoint, version)

  router := routing.New()

	router.Get("/healthcheck", func(c *routing.Context) error {
		fmt.Fprintf(c, `{"ok": true, "error": null}`)
		return nil
	})

  router.Get(fmt.Sprintf("%s/doc", ep), func(c *routing.Context) error {
    fmt.Fprintf(c, `{"ok": true, "error": null}`)
    return nil
  })

  router.Get(fmt.Sprintf("%s/auth", ep), func(c *routing.Context) error {
    fmt.Fprintf(c, `{"ok": true, "error": null, "data": "Future authorisation start"}`)
    return nil
  })

  router.Post(fmt.Sprintf("%s/auth", ep), func(c *routing.Context) error {
    fmt.Fprintf(c, `{"ok": true, "error": null, "data": "Future authorisation end"}`)
    return nil
  })

  router.Get(fmt.Sprintf("%s/check/<timestamp>", ep), func(c *routing.Context) error {
    timestamp := c.Param("timestamp")
    if timestamp == "" {
      fmt.Fprintf(c, `{"ok": false, "error": "No timestamp provided"}`)
      return nil
    }
    combo := countBD(timestamp)
    if combo == nil {
      fmt.Fprintf(c, `{"ok": false, "error": "Timestamp corrupted"}`)
      return nil
    }
    finalCombos := setAllCombos(combo)
    fmt.Fprintf(c, `{"ok": true, "error": null, "data": "Future date check endpoint. Currently received: %v. Combo is: %v. All combos are: %v"}`, timestamp, combo, finalCombos)
    return nil
  })

  router.Get(fmt.Sprintf("%s/check/past/<timestamp>", ep), func(c *routing.Context) error {
    timestamp := c.Param("timestamp")
    if timestamp == "" {
      fmt.Fprintf(c, `{"ok": false, "error": "No timestamp provided"}`)
      return nil
    }
    combo := countBD(timestamp)
    if combo == nil {
      fmt.Fprintf(c, `{"ok": false, "error": "Timestamp corrupted"}`)
      return nil
    }
    finalCombos := setAllCombos(combo)
    fmt.Fprintf(c, `{"ok": true, "error": null, "data": "Future date check endpoint. Currently received: %v. Combo is: %v. Past life combo is: [%v %v %v]"}`, timestamp, combo, finalCombos[8], finalCombos[9], finalCombos[0])
    return nil
  })

  // combo := countBD("834883200")
  // finalCombos := setAllCombos(combo)

  // fmt.Println(finalCombos)

  if err := fasthttp.ListenAndServe(*addr, router.HandleRequest); err != nil {
    log.Fatalf("Error in ListenAndServe: %s", err)
  }
}

func countBD(bd string) []int {
  i, err := strconv.ParseInt(bd, 10, 64)
  if err != nil {
    log.Print(err)
    return nil
  }
  tm := time.Unix(i, 0).String()
  UNIXsplit := strings.Split(tm, " ")
  date := UNIXsplit[0]
  dateSplit := strings.Split(date, "-")
  yearSplit := strings.Split(dateSplit[0],"")
  parsedYearOne, _ := strconv.ParseInt(yearSplit[0], 10, 64)
  parsedYearTwo, _ := strconv.ParseInt(yearSplit[1], 10, 64)
  parsedYearThree, _ := strconv.ParseInt(yearSplit[2], 10, 64)
  parsedYearFour, _ := strconv.ParseInt(yearSplit[3], 10, 64)
  probDay, _ := strconv.ParseInt(dateSplit[2], 10, 64)
  probMonth, _ := strconv.ParseInt(dateSplit[1], 10, 64)
  daySum := checkGreater(int(probDay))
  monthSum := probMonth
  yearSum := checkGreater(int(parsedYearOne + parsedYearTwo + parsedYearThree + parsedYearFour))
  return []int{int(daySum), int(monthSum), int(yearSum)}
}

func checkGreater(inum int) int {
  if inum > 22 {
    oinum := inum
    inum = 0
    for _, r := range strings.Split(strconv.Itoa(oinum),"") {
      num, err := strconv.Atoi(r)
      if err != nil {
        log.Print(err)
      }
      inum = inum + num
    }
  }
  return inum
}

func setAllCombos(icombo []int) []int {
  d  := checkGreater(icombo[0]+icombo[1]+icombo[2])
  e  := checkGreater(d*2)
  a1 := checkGreater(icombo[0]+e)
  a2 := checkGreater(icombo[0]+a1)
  b1 := checkGreater(icombo[1]+e)
  b2 := checkGreater(icombo[1]+b1)
  c1 := checkGreater(icombo[2]+e)
  c2 := checkGreater(icombo[2]+c1)
  d1 := checkGreater(d+e)
  d2 := checkGreater(d+d1)
  x  := checkGreater(c1+d1)
  x1 := checkGreater(d1+x)
  x2 := checkGreater(c1+x)
  f  := checkGreater(icombo[0]+icombo[1])
  g  := checkGreater(icombo[1]+icombo[2])
  y  := checkGreater(icombo[2]+d)
  k  := checkGreater(icombo[0]+d)
  e1 := checkGreater(f+g+y+k)
  e2 := checkGreater(e+e1)
  o  := checkGreater(f+y)
  u  := checkGreater(k+g)
  h  := checkGreater(icombo[1]+d)
  j  := checkGreater(icombo[0]+icombo[2])
  m  := checkGreater(h+j)
  n  := checkGreater(f+y)
  t  := checkGreater(g+k)
  z  := checkGreater(n+t)
  s  := checkGreater(m+z)
  b3 := checkGreater(b1+e)
  a3 := checkGreater(a1+e)
  l  := checkGreater(icombo[0]+icombo[1])
  l1 := checkGreater(a2+b2)
  l2 := checkGreater(a1+b1)
  l3 := checkGreater(a3+b3)
  l4 := checkGreater(e*2)
  l5 := checkGreater(d1+c1)
  l6 := checkGreater(icombo[2]+d)
  d3 := checkGreater(icombo[0]+a2+a1+a3+e+d1+d)
  c3 := checkGreater(icombo[1]+b2+b1+b3+e+c1+icombo[2])
  e3 := checkGreater(l+l1+l2+l3+l4+l5+l6)
  return []int{d,e,a1,a2,b1,b2,c1,c2,d1,d2,x,x1,x2,f,g,h,y,k,e1,e2,o,u,h,j,m,n,
    t,z,s,b3,a3,l,l1,l2,l3,l4,l5,l6,d3,c3,e3}
}
